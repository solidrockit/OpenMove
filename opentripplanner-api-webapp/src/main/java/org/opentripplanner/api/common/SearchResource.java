/* This program is free software: you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public License
 as published by the Free Software Foundation, either version 3 of
 the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>. */

package org.opentripplanner.api.common;

import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.ws.rs.DefaultValue;
import javax.ws.rs.QueryParam;

import org.onebusaway.gtfs.model.AgencyAndId;
import org.opentripplanner.api.core.VertexRequest;
import org.opentripplanner.common.ParameterException;
import org.opentripplanner.routing.request.BannedStopSet;
import org.opentripplanner.routing.services.GraphService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.sun.jersey.api.core.InjectParam;
import com.vividsolutions.jts.geom.Coordinate;

/**
 * This class defines all the JAX-RS query parameters for a path search as fields, allowing them to 
 * be inherited by other REST resource classes (the trip planner and the Analyst WMS or tile 
 * resource). They will be properly included in API docs generated by Enunciate. This implies that
 * the concrete REST resource subclasses will be request-scoped rather than singleton-scoped.
 * 
 * @author fidenet
 */
public abstract class SearchResource { 

    private static final Logger LOG = LoggerFactory.getLogger(SearchResource.class);

    private static final String _doublePattern = "-{0,1}\\d+(\\.\\d+){0,1}";
    private static final Pattern _latLonPattern = Pattern.compile("^\\s*(" + _doublePattern
            + ")(\\s*,\\s*|\\s+)(" + _doublePattern + ")\\s*$");
    
    /* TODO do not specify @DefaultValues here, so all defaults are handled in one place */
    
    /** The start location -- either latitude, longitude pair in degrees or a Vertex
     *  label. For example, <code>40.714476,-74.005966</code> or
     *  <code>mtanyctsubway_A27_S</code>.  */
    
    @QueryParam("location") protected List<String> location;
    @DefaultValue("en_US") @QueryParam("locale")
    private List<String> locale;
    
    /* 
     * somewhat ugly bug fix: the graphService is only needed here for fetching per-graph time zones. 
     * this should ideally be done when setting the routing context, but at present departure/
     * arrival time is stored in the request as an epoch time with the TZ already resolved, and other
     * code depends on this behavior. (AMB)
     * Alternatively, we could eliminate the separate RoutingRequest objects and just resolve
     * vertices and timezones here right away, but just ignore them in semantic equality checks.
     */
    @InjectParam
    protected GraphService graphService;
    @InjectParam
    protected VertexRequest prototypeVertexRequest;
    /** 
     * Build the 0th Request object from the query parameter lists. 
     * @throws ParameterException when there is a problem interpreting a query parameter
     */
    protected VertexRequest buildRequest() throws ParameterException {
        return buildRequest(0);
    }
    
    
    /** 
     * Range/sanity check the query parameter fields and build a Request object from them.
     * @param  n allows building several request objects from the same query parameters, 
     *         re-specifying only those parameters that change from one request to the next. 
     * @throws ParameterException when there is a problem interpreting a query parameter
     */
    protected VertexRequest buildRequest(int n) throws ParameterException {
        
        // TODO Begiratu ea clone-k zergatik ematen duen errorea
        VertexRequest request = new VertexRequest(); //this.prototypeVertexRequest.clone();
        
        request.setLocation(get(location, n, request.getLocationPlace().getRepresentation()));

        // Calculate the location's coordinates
        Matcher matcher = _latLonPattern.matcher(request.getLocationPlace().place);
        if (matcher.matches()) {
            double lat = Double.parseDouble(matcher.group(1));
            double lon = Double.parseDouble(matcher.group(4));
            Coordinate location = new Coordinate(lon, lat);
            request.setLocationCoord(location);
        }
        
        String localeSpec = get(locale, n, "en");
        String[] localeSpecParts = localeSpec.split("_");
        Locale locale;
        switch (localeSpecParts.length) {
            case 1:
                locale = new Locale(localeSpecParts[0]);
                break;
            case 2:
                locale = new Locale(localeSpecParts[0]);
                break;
            case 3:
                locale = new Locale(localeSpecParts[0]);
                break;
            default:
                LOG.debug("Bogus locale " + localeSpec + ", defaulting to en");
                locale = new Locale("en");
        }

        request.setLocale(locale);
        return request;
    }
    
    private HashMap<AgencyAndId, BannedStopSet> makeBannedTripMap(String banned) {
        if (banned == null) {
            return null;
        }
        
        HashMap<AgencyAndId, BannedStopSet> bannedTripMap = new HashMap<AgencyAndId, BannedStopSet>();
        String[] tripStrings = banned.split(",");
        for (String tripString : tripStrings) {
            String[] parts = tripString.split(":");
            String tripIdString = parts[0];
            AgencyAndId tripId = AgencyAndId.convertFromString(tripIdString);
            BannedStopSet bannedStops;
            if (parts.length == 1) {
                bannedStops = BannedStopSet.ALL;
            } else {
                bannedStops = new BannedStopSet();
                for (int i = 1; i < parts.length; ++i) {
                    bannedStops.add(Integer.parseInt(parts[i]));
                }
            }
            bannedTripMap.put(tripId, bannedStops);
        }
        return bannedTripMap;
    }

/**
 * @param l list of query parameter values
 * @param n requested item index 
 * @return nth item if it exists, closest existing item otherwise, or defaultValue if the list l 
 *         is null or empty.
 */
    private <T> T get(List<T> l, int n, T defaultValue) {
        if (l == null || l.size() == 0)
            return defaultValue;
        int maxIndex = l.size() - 1;
        if (n > maxIndex)
            n = maxIndex;
        T value = l.get(n);
        if (value instanceof Integer) {
            if (value.equals(-1)) {
                return defaultValue;
            }
        } else if (value instanceof Double) {
            if (value.equals(-1.0)) {
                return defaultValue;
            }
        }
        return value;
    }

}
